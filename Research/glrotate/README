Иллюстрация вращений поисковых деревьев в виде OpenGL-программы.

В планах:
1. Size Binary Tree (SBT)
2. AVL-tree

Ссылки:
1. Двоичное дерево поиска, http://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0
2. Красно-чёрное дерево, http://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B0%D1%81%D0%BD%D0%BE-%D1%87%D0%B5%D1%80%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE
3. АВЛ-дерево, http://ru.wikipedia.org/wiki/%D0%90%D0%92%D0%9B-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE
4. Двоичные деревья (начальные сведения), http://algolist.manual.ru/ds/btree.php
5. Двоичные деревья поиска (RSDN), http://www.rsdn.ru/article/alg/binstree.xml

Реализация визуализатора
- шаг отображения - 50 мс (миллисекунд)
- если ребру надо передвинуться на 20 делений за 1 секунду - оно успеет это сделать (20x50 = 1000 мс)
- дискретности визуализатора должно хватать для создания впечатления анимации рёбер (конечно, это не голливудское качество)

Идея визуализатора:
1) Добавить в движок, формирующий деревья, callback-функции - сообщающие в результате операций над деревом.
2) "Прогнать" все операции над деревом - запомнив "срезы" в специальных структурах [визуализатора].
3) Какие это структуры? В принципе, хватило бы "снимков" дерева. Но для минимизации хранимых данных -
   вычисляем и запоминаем следующее.
   Первое (вычисляем) - координаты вершин на плоскости (обходим дерево, вычисляем координаты).
   Второе (запоминаем) - над какой парой вершин выполнено "rotate" (ребро).
   Третье (запоминаем) - конфигурацию связей на каждом шаге.
   Благодаря этим пунктам, можно "проигрывать" мультик как "вперёд", так и "назад".

   0  1  2  3  4  5  ...
   A  B  C  D  E  F  ...
   left  ----  ----
   right ----  ----  ...
   parent ---  ----


Принципы визуализации
1) Движки построения деревьев (например, sbt) не должны ничего знать о визуализаторах.
Чтобы наращивание функций визуализатора не затрагивало "движок". Движок должен предоставлять
достаточное число callback-функций или структур данных для экспорта необходимой информации
для визуализации.
2) Генератор вызывает callback-функции, которые я ему показал (по указателям),
а визуализатор как бы получается event-driven системой - реагирует на полученные
от генератора вызовы.
3) Использование callback-функций позволяет избежать #defines для DEBUG-printf.

Послесловие
Выполнение этой задачи полезно для последующей визуализации связей (links).
