using System;
using System.Collections.Generic;

namespace Platform.Data.Core.Doublets
{
    /// <summary>
    /// Представляет интерфейс для работы с данными в формате Links (хранилища взаимосвязей).
    /// </summary>
    public interface ILinks<TLink>
    {
        #region Constants

        /// <summary>
        /// Возвращает набор констант, который необходим для эффективной коммуникации с методами этого интерфейса.
        /// Эти константы не меняются с момента создания точки доступа к хранилищу.
        /// </summary>
        ILinksCombinedConstants<TLink, TLink, int> Constants { get; }

        #endregion

        #region Read

        /// <summary>
        /// Подсчитывает и возвращает общее число связей находящихся в хранилище, соответствующих указанным ограничениям.
        /// </summary>
        /// <param name="restriction">Ограничения на содержимое связей.</param>
        /// <returns>Общее число связей находящихся в хранилище, соответствующих указанным ограничениям.</returns>
        TLink Count(params TLink[] restriction);

        /// <summary>
        /// Выполняет проход по всем связям, соответствующим шаблону, вызывая обработчик (handler) для каждой подходящей связи.
        /// </summary>
        /// <param name="handler">Обработчик каждой подходящей связи.</param>
        /// <param name="restrictions">Ограничения на содержимое связей. Каждое ограничение может иметь значения: Constants.Null - 0-я связь, обозначающая ссылку на пустоту, Any - отсутствие ограничения, 1..∞ конкретный адрес связи.</param>
        /// <returns>True, в случае если проход по связям не был прерван и False в обратном случае.</returns>
        TLink Each(Func<IList<TLink>, TLink> handler, IList<TLink> restrictions);

        #endregion

        #region Write

        /// <summary>
        /// Создаёт связь (если она не существовала), либо возвращает индекс существующей связи с указанными Source (началом) и Target (концом).
        /// </summary>
        /// <returns>Индекс связи, с указанным Source (началом) и Target (концом)</returns>
        TLink Create(); // TODO: Возможно всегда нужно принимать restrictions, возможно и возвращать связь нужно целиком.

        // 10001

        /// <summary>
        /// Обновляет связь с указанными началом (Source) и концом (Target)
        /// на связь с указанными началом (NewSource) и концом (NewTarget).
        /// </summary>
        /// <param name="restriction">Ограничения на содержимое связей. Каждое ограничение может иметь значения: Constants.Null - 0-я связь, обозначающая ссылку на пустоту, Itself - требование установить ссылку на себя, 1..∞ конкретный адрес другой связи.</param>
        /// <returns>Индекс обновлённой связи.</returns>
        TLink Update(IList<TLink> restrictions); // TODO: Возможно и возвращать связь нужно целиком.

        /// <summary>Удаляет связь с указанным индексом.</summary>
        /// <param name="link">Индекс удаляемой связи.</param>
        void Delete(TLink link); // TODO: Возможно всегда нужно принимать restrictions, a так же возвращать удалённую связь, если удаление было реально выполнено, и Null, если нет.

        // TODO: Если учесть последние TODO, тогда все функции Create, Update, Delete будут иметь один и тот же интерфейс - IList<TLink> Method(IList<TLink> restrictions);, что может быть удобно для "Create|Update|Delete" транзакционности, !! но нужна ли такая транзакционность? Ведь всё что нужно записывать в транзакцию это изменение с чего в во что. Создание это index, 0, 0 -> index, X, Y (и начало отслеживания связи). Удаление это всегда index, X, Y -> index, 0, 0 (и прекращение отслеживания связи). Обновление - аналогично, но состояние отслеживания не меняется.
        // TODO: Хотя пожалуй, выдавать дополнительное значение в виде True/False вряд ли допустимо для Delete. Тогда создание это 0,0,0 -> I,S,T и т.п.

        #endregion
    }
}
