//using System;

//namespace Platform.Links.DataBase.Core.Elements
//{
//    /// <summary>
//    /// Инкапсулирует метод, обрабатывающий элемент.
//    /// Метод получает адрес, значение, левое продолжение и правое продолжение элемента.
//    /// Метод возвращает значение, определяющие, был ли прерван процесс обработки (Продолжен - True, Прерван - False).
//    /// </summary>
//    /// <typeparam name="TElement">Тип индекса (идентификатора/адреса) элемента.</typeparam>
//    /// <param name="address">Адрес элемента.</param>
//    /// <param name="value">Индекс элемента, который является значением элемента.</param>
//    /// <param name="left">Индекс левого (Left) элемента, который будет является продолжением создаваемого элемента влево.</param>
//    /// <param name="right">Индекс правого (Right) элемента, который является продолжением элемента вправо.</param>
//    /// <returns>True, в случае если проход по связям был продолжен обработчиком и False в обратном случае (прерван).</returns>
//    public delegate bool ElementHandler<in TElement>(TElement address, TElement value, TElement left, TElement right);

//    /// <summary>
//    /// Представляет интерфейс для работы с базой данных (хранилищем)
//    /// в формате Elements (хранилища элементов и составных элементов (последовательностей)).
//    /// </summary>
//    /// <typeparam name="TElement">Тип индекса (идентификатора/адреса) элемента.</typeparam>
//    /// <remarks>Здесь располагается методы соотствующие шаблону Create-Read-Update-Delete (CRUD).</remarks>
//    public partial interface IElements<TElement>
//    {
//        /// <summary>
//        /// Создаёт элемент (если он ещё не существует), либо возвращает индекс существующего элемента
//        /// с указанными Left (продолжением слева), Value (значением) и Right (продолжением справа).
//        /// </summary>
//        /// <param name="left">Индекс левого (Left) элемента, который будет является продолжением создаваемого элемента влево.</param>
//        /// <param name="value">Индекс элемента, который будет являться значением данного создаваемого элемента.</param>
//        /// <param name="right">Индекс правого (Right) элемента, который будет являться продолжением создаваемого элемента вправо.</param>
//        /// <returns>Индекс созданного или существующего элемента, с указанным Left (продолжением влево), Value (значением) и Right (продолжением вправо)</returns>
//        /// <remarks>
//        /// Традиционно последовательности (строки, массивы) и т.п. представлены в виде ссылок на их начало
//        /// (может присутствовать информация о длине последовательности или есть соглашение о том, что символизирует окончание последовательности).
//        /// Уникальность последовательностей не гарантируются, может существовать несколько одинаковых последовательностей.
//        /// Чтобы узнать как взаимосвязаны эти последовательности необходимо выполнять дополнительные вычисления.
//        /// Выделение памяти происходит по требованию, могут возникать проблемы с неравномерным выделением памяти.
//        /// (В те места, где память высвободилась память нельзя разместить новые элементы без перемещение используемой памяти)
//        /// Не хранятся обратные ссылки на указатели (что требует статического размещения информации в памяти, затрудняет её перемещение).
//        /// </remarks>
//        TElement Create(TElement left, TElement value, TElement right);

//        /// <summary>
//        /// Пишет (обновляет) элемент (если он ещё не существует), либо возвращает индекс существующего элемента
//        /// с указанными Left (продолжением слева), Value (значением) и Right (продолжением справа).
//        /// </summary>
//        /// <param name="left">Индекс левого (Left) элемента, который будет является продолжением создаваемого элемента влево.</param>
//        /// <param name="value">Индекс элемента, который будет являться значением данного создаваемого элемента.</param>
//        /// <param name="right">Индекс правого (Right) элемента, который будет являться продолжением создаваемого элемента вправо.</param>
//        /// <returns>Индекс созданного или существующего элемента, с указанным Left (продолжением влево), Value (значением) и Right (продолжением вправо)</returns>
//        /// <remarks>
//        /// Традиционно последовательности (строки, массивы) и т.п. представлены в виде ссылок на их начало
//        /// (может присутствовать информация о длине последовательности или есть соглашение о том, что символизирует окончание последовательности).
//        /// Уникальность последовательностей не гарантируются, может существовать несколько одинаковых последовательностей.
//        /// Чтобы узнать как взаимосвязаны эти последовательности необходимо выполнять дополнительные вычисления.
//        /// Выделение памяти происходит по требованию, могут возникать проблемы с неравномерным выделением памяти.
//        /// (В те места, где память высвободилась память нельзя разместить новые элементы без перемещение используемой памяти)
//        /// Не хранятся обратные ссылки на указатели (что требует статического размещения информации в памяти, затрудняет её перемещение).
//        /// TODO: Решить обновлять ли все элементы в последовательности (составном элементе), если обновляется один из них?
//        /// </remarks>
//        TElement Write(ref TElement address, TElement left, TElement value, TElement right);

//        /// <summary>
//        /// Возвращает значение, определяющее существует ли элемент с указанным индексом в базе данных (хранилище).
//        /// </summary>
//        /// <param name="element">Индекс проверяемого на существование элемента.</param>
//        /// <returns>Значение, определяющее существует ли связь.</returns>
//        bool Exists(TElement element);

//        /// <summary>Удаляет элемент с указанным индексом.</summary>
//        /// <param name="element">Индекс удаляемого элемента.</param>
//        /// <remarks>
//        /// Возможно имеет смысл все ссылки на другие элементы принимать по ref (ссылке)
//        /// и если указанная ссылка не является корректной - обнулять её (чтобы хранение неверных ссылок не стало ошибкой в будущем).
//        /// Тогда в функции exists не нужно будет возвращать тип bool.
//        /// TODO: Решить удалять ли все элементы в последовательности (составном элементе), если удаляется один из них?
//        /// </remarks>
//        void Delete(ref TElement element);

//        /// <summary>
//        /// 
//        /// </summary>
//        /// <param name="address"></param>
//        /// <param name="handler"></param>
//        /// <returns>True, в случае если проход по связям не был прерван и False в обратном случае.</returns>
//        bool EachAddress(TElement address, ElementHandler<TElement> handler);

//        /// <summary>
//        /// Выполняет проход по всем связям, соответствующим шаблону, вызывая обработчик (handler) для каждого подходходящего элемента.
//        /// </summary>
//        /// <param name="value">Значение, определяющее соответствующие шаблону связи. (0 - любое конец, 1..∞ конкретный конец)</param>
//        /// <param name="handler">Обработчик каждой подходящей связи.</param>
//        /// <returns>True, в случае если проход по связям не был прерван и False в обратном случае.</returns>
//        /// <remarks>
//        /// TODO:
//        /// Безопасно ли удаление в процессе прохода? - Если это будет двусвязный список, то да.
//        /// </remarks>
//        bool EachValue(TElement value, Func<TElement> handler);
//    }
//}
