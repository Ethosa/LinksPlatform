using System;

namespace Platform.Links.System.Memory
{
    /// <summary>
    /// Представляет интерфейс блока памяти.
    /// </summary>
    /// <remarks>
    /// Возможно, если дать настройку - инициализировать ли нулями выделяемую память можно немного выиграть в производительности,
    /// однако потерять в надёжности и стабильности при разработке.
    /// Возможно ReservedCapacity - лишнее свойство, и управлять размером блока можно через что-то одно.
    /// Либо может быть ReservedCapacity можно сделать readonly.
    /// Возможно нужна настройка, определяющая блоками какого размера растёт блок памяти.
    /// Можно ли как-то отлавливать ошибки при обращении к некорректному указателю и
    /// автоматически трактовать это как команду к расширению блока?
    /// 
    /// Что, если IMemory передавать в Links или туда, где он используется?
    /// 
    /// Как поддержать два разных поведения?
    /// Например блок с изменяемым размером памяти и неизменяемым.
    /// Возможно имеет смысл добавить свойство IsResizable?
    /// Возможно имеет сделать два отдельных типа IMemory, один из них будет Fixed, другой Resizable?
    /// 
    /// А что, если мы хотим иметь распределённую память, храняющуюся на нескольких машинах?
    /// 
    /// Асинхронный доступ к памяти? (Для операций выделения памяти, обращения к памяти, изменения размера блока)
    /// 
    /// Нехранимая память? Лог?
    /// </remarks>
    public unsafe interface IMemory : IDisposable
    {
        /// <summary>
        /// Возвращает указатель на начало блока памяти.
        /// </summary>
        void* Pointer { get; }

        /// <summary>
        /// Возвращает или устаналивает зарезервированный размер блока памяти в байтах.
        /// </summary>
        long ReservedCapacity { get; set; }

        /// <summary>
        /// Возвращает или устанавливает используемый размер в блоке памяти (в байтах).
        /// При выполнении метода Dispose, размер файла будет автоматически усечён до этого размера.
        /// </summary>
        long UsedCapacity { get; set; }
    }
}